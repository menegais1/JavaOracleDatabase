package DatabaseAccess.Model;


import DatabaseAccess.DatabaseConnection;
import DatabaseAccess.Tuple;
import DatabaseAccess.TypeMapping;

import java.lang.reflect.*;


import java.sql.JDBCType;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Entity {


    public Entity(ResultSet result) {
        fillEntity(result);
    }

    public Entity() {

    }

    public void fillEntity(ResultSet result) {
        Field[] fields = this.getClass().getDeclaredFields();
        for (Field field : fields) {
            try {
                if (Modifier.isPublic(field.getModifiers()))
                    field.set(this, result.getObject(field.getName(), field.getType()));
            } catch (IllegalAccessException | SQLException e) {
                e.printStackTrace();
            }
        }
    }

    public <T> T getSingle(int id, DatabaseConnection db) throws SQLException {
        String tableName = getTableName(this.getClass());
        ResultSet result = db.ExecuteQuery("SELECT * FROM " + tableName + " WHERE ID = ?",
                new Tuple[]{
                        new Tuple<Object, JDBCType>(id, JDBCType.INTEGER)
                });
        Entity e = null;
        result.next();
        try {
            e = getClass().getConstructor(ResultSet.class).newInstance(result);
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException ex) {
            ex.printStackTrace();
        }
        db.CloseStatement(result.getStatement());
        return (T) e;
    }

    public <T> List<T> getAll(DatabaseConnection db) throws SQLException {
        String tableName = getClass().getName();
        String[] split = tableName.split("\\.");
        tableName = split[split.length - 1];
        ResultSet result = db.ExecuteQuery("SELECT * FROM " + tableName, null);
        List<T> entities = new ArrayList<>();
        while (result.next()) {
            try {
                entities.add((T) getClass().getConstructor(ResultSet.class).newInstance(result));
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
                e.printStackTrace();
            }

        }
        db.CloseStatement(result.getStatement());
        return entities;
    }

    public <T> long insert(T e, String[] fields, DatabaseConnection db) {

        String tableName = getTableName(e.getClass());
        List<Field> classFields = getFields(e, fields);

        StringBuilder queryBuilder = new StringBuilder("INSERT INTO " + tableName);
        queryBuilder.append(insertQueryFieldsValue(e, classFields));
        Tuple<Object, JDBCType>[] binds = getBindings(e, classFields);
        try {
            ResultSet r = db.Execute(queryBuilder.toString(), binds);
            r.next();
            return r.getLong(1);
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
        return -1;
    }

    private <T> Tuple<Object, JDBCType>[] getBindings(T e, List<Field> fields) {
        Tuple<Object, JDBCType>[] binds = new Tuple[fields.size()];

        for (int i = 0; i < fields.size(); i++) {
            Field field = fields.get(i);
            try {
                binds[i] = new Tuple<>(field.get(e), TypeMapping.getJDBCType(field.getType()));
            } catch (IllegalAccessException ex) {
                binds[i] = new Tuple<>(null, JDBCType.NULL);
            }
        }
        return binds;
    }

    private <T> List<Field> getFields(T e, String[] fields) {
        List<Field> classFields = new ArrayList<>();
        if (fields != null && fields.length > 0 && fields[0].equals("*"))
            classFields.addAll(Arrays.asList(e.getClass().getFields()));
        else {
            for (String field : fields) {
                try {
                    classFields.add(e.getClass().getField(field));
                } catch (NoSuchFieldException ex) {
                    ex.printStackTrace();
                }
            }
        }
        classFields.removeIf(field -> field.isAnnotationPresent(AutoGenerated.class));

        return classFields;
    }

    private <T> String insertQueryFieldsValue(T e, List<Field> fields) {

        StringBuilder queryBuilder = new StringBuilder("(");
        for (Field field : fields) {
            queryBuilder.append(field.getName()).append(",");
        }
        queryBuilder.replace(queryBuilder.lastIndexOf(","), queryBuilder.lastIndexOf(",") + 1, ")");
        queryBuilder.append(" VALUES(");
        for (Field field : fields) {
            queryBuilder.append("?,");
        }
        queryBuilder.replace(queryBuilder.lastIndexOf(","), queryBuilder.lastIndexOf(",") + 1, ")");

        return queryBuilder.toString();
    }

    private String getTableName(Class<?> t) {
        String tableName = "";
        if (t.isAnnotationPresent(Table.class)) {
            tableName = t.getAnnotation(Table.class).name();
        } else {
            tableName = t.getName();
            String[] split = tableName.split("\\.");
            tableName = split[split.length - 1];
        }

        return tableName;

    }
}
